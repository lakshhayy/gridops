diff --git a/optimizer/main.py b/optimizer/main.py
index 20308b3..6ba2bf1 100644
--- a/optimizer/main.py
+++ b/optimizer/main.py
@@ -1,5 +1,6 @@
 import logging
 import os
+from datetime import datetime
 from fastapi import FastAPI, HTTPException, status
 from pydantic import BaseModel, Field
 import numpy as np
@@ -23,6 +24,23 @@ class SimulationRequest(BaseModel):
     ac_setpoint: float = Field(..., ge=16.0, le=32.0, description="Target HVAC temperature in Celsius")
     reduction_factor: float = Field(..., ge=0.0, le=1.0, description="Load shedding percentage (0-1)")
     enable_incentives: bool = Field(default=False, description="Apply DISCOM demand response rebates")
+    # Task 1: Timestamp
+    timestamp: str = Field(default=None, description="ISO 8601 timestamp")
+    # Task 2: Carbon Intensity
+    grid_carbon_intensity: float = Field(default=0.82, ge=0.0, le=2.0, description="kgCO2/kWh")
+    # Task 3: Grid Frequency
+    grid_frequency: float = Field(default=50.0, ge=45.0, le=55.0, description="Grid Frequency in Hz")
+    # Task 4: Power Factor
+    power_factor: float = Field(default=0.90, ge=0.1, le=1.0, description="Power Factor")
+    # Task 5: Grid Voltage
+    grid_voltage: float = Field(default=230.0, ge=150.0, le=300.0, description="Grid Voltage in Volts")
+    # Task 6: Battery
+    battery_capacity: float = Field(default=0.0, ge=0.0, description="Battery Capacity in kWh")
+    current_charge: float = Field(default=0.0, ge=0.0, le=100.0, description="Current Battery Charge %")
+    # Task 7: Humidity
+    relative_humidity: float = Field(default=60.0, ge=0.0, le=100.0, description="Relative Humidity %")
+    # Task 8: Occupancy
+    occupancy_count: int = Field(default=20, ge=0, description="Number of occupants")
 
 class SimulationResponse(BaseModel):
     projected_kwh: float
@@ -31,73 +49,112 @@ class SimulationResponse(BaseModel):
     comfort_index: float
     grid_stability_score: float
 
-# --- Physics Constants (Delhi NCR Region) ---
-# Baseline assumes a 50,000 sqft commercial facility
+# --- Physics Constants ---
 BASE_LOAD_KWH = 28500.0  
-THERMAL_COEFF = 0.085    # ~8.5% energy delta per degree C (ASHRAE approximation)
-CARBON_INTENSITY = 0.82  # kgCO2/kWh (Grid India average)
-PEAK_TARIFF = 12.50      # INR/kWh
-OFF_PEAK_TARIFF = 8.50   # INR/kWh
+THERMAL_COEFF = 0.085    
+PEAK_TARIFF = 12.50      
+OFF_PEAK_TARIFF = 8.50   
 
 @app.get("/health")
 async def health_check():
-    """K8s/Docker health probe endpoint."""
     return {"status": "healthy", "service": "optimizer"}
 
 @app.post("/calculate", response_model=SimulationResponse)
 async def calculate_impact(payload: SimulationRequest):
     try:
-        logger.info(f"Processing simulation for setpoint: {payload.ac_setpoint}C")
+        # 1. Determine Time & Tariff (Task 1)
+        hour = 12
+        if payload.timestamp:
+            try:
+                dt = datetime.fromisoformat(payload.timestamp)
+                hour = dt.hour
+            except ValueError:
+                pass
+        
+        current_tariff = 10.0 # Standard Rate
+        if 14 <= hour < 20:
+            current_tariff = PEAK_TARIFF 
+        elif hour >= 23 or hour < 8:
+            current_tariff = OFF_PEAK_TARIFF
+
+        # 2. Safety & Grid Overrides (Task 2, 3, 5)
+        effective_reduction = payload.reduction_factor
+        is_surge_event = False
+
+        if payload.grid_voltage > 255.0:
+            effective_reduction = 1.0 # Task 5: Surge Protection
+            is_surge_event = True
+        elif payload.grid_frequency < 49.8:
+            effective_reduction = 0.50 # Task 3: Emergency Mode
+        elif payload.grid_voltage < 200.0:
+            effective_reduction = max(effective_reduction, 0.5) # Task 5: Brownout
+        elif payload.grid_carbon_intensity > 0.90:
+            effective_reduction = max(effective_reduction, 0.2) # Task 2: Dirty Grid
+
+        # 3. Thermal efficiency (Task 7)
+        effective_coeff = THERMAL_COEFF
+        if payload.relative_humidity > 60.0:
+            penalty = (payload.relative_humidity - 60.0) * 0.01
+            effective_coeff = THERMAL_COEFF / (1.0 + penalty)
 
-        # 1. Thermal Load Calculation
-        # Using simplified Degree-Day method. Baseline assumed at 22C.
-        # Physics: Q = U * A * Delta T
         delta_t = max(0, payload.ac_setpoint - 22.0)
+        thermal_savings_pct = np.tanh(delta_t * effective_coeff)
         
-        # Non-linear savings curve (diminishing returns > 26C)
-        # Using numpy for efficient calculation
-        thermal_savings_pct = np.tanh(delta_t * THERMAL_COEFF)
-        
-        # 2. Load Shedding Impact
-        shedding_savings = BASE_LOAD_KWH * payload.reduction_factor
+        # 4. Net Load Calculation (Task 6)
+        shedding_savings = BASE_LOAD_KWH * effective_reduction
         thermal_savings = BASE_LOAD_KWH * thermal_savings_pct
-        
-        total_savings_kwh = thermal_savings + shedding_savings
-        final_load = max(0, BASE_LOAD_KWH - total_savings_kwh)
+        building_load = max(0, BASE_LOAD_KWH - (thermal_savings + shedding_savings))
 
-        # 3. Financial Modeling
-        # Blended rate assumption (60% peak / 40% off-peak)
-        blended_rate = (PEAK_TARIFF * 0.6) + (OFF_PEAK_TARIFF * 0.4)
-        base_cost = final_load * blended_rate
+        battery_impact = 0.0
+        if payload.battery_capacity > 0:
+            if current_tariff < 9.0:
+                battery_impact = payload.battery_capacity * 0.5 # Charging
+            elif current_tariff > 12.0:
+                battery_impact = -(payload.battery_capacity * 0.5) # Discharging
         
-        dr_rebate = 5000.0 if payload.enable_incentives else 0.0
-        final_cost = max(0, base_cost - dr_rebate)
+        final_load = max(0, building_load + battery_impact)
+        if is_surge_event: final_load = 0.0
 
-        # 4. Comfort Index Calculation (ASHRAE 55 simplified)
-        # 1.0 = Perfect, 0.0 = Uninhabitable
+        # 5. Financial Modeling (Task 4)
+        pf_multiplier = 1.0
+        if payload.power_factor < 0.90:
+            pf_multiplier = 1.0 + (0.90 - payload.power_factor)
+        elif payload.power_factor > 0.95:
+            pf_multiplier = 1.0 - ((payload.power_factor - 0.95) * 0.5)
+
+        base_cost = final_load * current_tariff * pf_multiplier
+        final_cost = max(0, base_cost - (5000.0 if payload.enable_incentives else 0.0))
+
+        # 6. Comfort Index Calculation (Task 8 Adjustments)
+        # --- FIX: INITIALIZE comfort_penalty HERE ---
         comfort_penalty = 0.0
         
+        temp_multiplier = 2.0 if payload.occupancy_count > 50 else 1.0
+        shed_multiplier = 0.5 if payload.occupancy_count < 10 else 1.0
+
         if payload.ac_setpoint > 24.0:
-            # Exponential penalty for high temps
-            comfort_penalty += ((payload.ac_setpoint - 24.0) ** 1.5) * 0.08
-            
-        if payload.reduction_factor > 0.15:
-            # Linear penalty for aggressive shedding
-            comfort_penalty += (payload.reduction_factor - 0.15) * 2.5
-            
+            comfort_penalty += ((payload.ac_setpoint - 24.0) ** 1.5) * 0.08 * temp_multiplier
+        if effective_reduction > 0.15:
+            comfort_penalty += (effective_reduction - 0.15) * 2.5 * shed_multiplier
+        
         comfort_score = max(0.1, 1.0 - comfort_penalty)
+        
+        # 7. Grid Stability Score (Task 4 & 5)
+        raw_stability = 0.85 + (effective_reduction * 0.15)
+        if is_surge_event:
+            grid_stability_score = 0.0
+        elif payload.power_factor < 0.85:
+            grid_stability_score = min(raw_stability, 0.6)
+        else:
+            grid_stability_score = raw_stability
 
         return {
             "projected_kwh": round(float(final_load), 2),
             "cost_estimate": round(float(final_cost), 2),
-            "carbon_footprint": round(float(final_load * CARBON_INTENSITY), 2),
+            "carbon_footprint": round(float(final_load * payload.grid_carbon_intensity), 2),
             "comfort_index": round(float(comfort_score), 3),
-            "grid_stability_score": round(0.85 + (payload.reduction_factor * 0.15), 3)
+            "grid_stability_score": round(float(grid_stability_score), 3)
         }
-
     except Exception as e:
         logger.error(f"Calculation failed: {str(e)}", exc_info=True)
-        raise HTTPException(
-            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
-            detail="Optimization engine computation error"
-        )
\ No newline at end of file
+        raise HTTPException(status_code=500, detail="Optimization engine computation error")
\ No newline at end of file
diff --git a/server/src/routes/simulation.routes.ts b/server/src/routes/simulation.routes.ts
index 8e71bb9..da03ad2 100644
--- a/server/src/routes/simulation.routes.ts
+++ b/server/src/routes/simulation.routes.ts
@@ -4,6 +4,7 @@ import { db } from '../db'; // We will create this next
 import { simulationLogs } from '../db/schema';
 import { z } from 'zod';
 
+
 const router = Router();
 
 // Validation schema
@@ -11,6 +12,7 @@ const SimulationSchema = z.object({
   acTemp: z.number().min(16).max(32),
   reductionPercent: z.number().min(0).max(100),
   incentives: z.boolean().optional()
+  occupancyCount: z.number().int().min(0).optional() 
 });
 
 router.post('/run', async (req: Request, res: Response) => {
@@ -21,6 +23,7 @@ router.post('/run', async (req: Request, res: Response) => {
       ac_setpoint: payload.acTemp,
       reduction_factor: payload.reductionPercent / 100,
       enable_incentives: payload.incentives || false
+      occupancy_count: payload.occupancyCount
     });
 
     // Async logging (fire and forget)
diff --git a/server/src/services/optimizer.service.ts b/server/src/services/optimizer.service.ts
index e4a5b50..b0e08dd 100644
--- a/server/src/services/optimizer.service.ts
+++ b/server/src/services/optimizer.service.ts
@@ -13,6 +13,7 @@ interface SimulationResult {
   carbon_footprint: number;
   comfort_index: number;
   grid_stability_score: number;
+  occupancy_count?: number;
 }
 
 export class OptimizerService {
